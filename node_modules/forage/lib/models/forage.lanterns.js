var lanterns,
    Q = require('q');
    
(function () {
    "use strict";
    
    var Forage = null;
    
    lanterns = function () {
        
        var self = this,
            parentGame = null;
        
        this.Lantern = require('../classes/forage.lantern');
        this.lanterns = {};
        
        Forage = module.parent.parent.parent.exports;
        
        this.parentGame = null;
        
        this.listAll = function (request, res) {
            var deferred = Q.defer(),
                result = [], i;
            
            for (i in self.lanterns) {
                result.push(self.lanterns[i]);
            }
            
            deferred.resolve(result);
            
            return deferred.promise;
        };
        
        this.setParent = function (parent) {
            parentGame = parent;
        };
        
        /***!Add an array of games
         *    addAll()
         * @params    (Array:resources)     The array of objects to use as bases for new games
         * @params    (Integer:index)       OPTIONAL Index of where to start processing at
         */
        this.loadAll = function (lanterns, index) {
            var deferred = Q.defer();

            // Set the index to the first if not provided
            index = index || 0;
            
            // If the index matches the lenth, there is no need to process
            if (index === lanterns.length) {
                deferred.resolve();
            } else {
                Forage.notify('Loading lantern ' + (index + 1) + ' of ' + lanterns.length);
                // Use the standard method to add a new game to the environment
                self.load(lanterns[index])
                    // Upon completing the adding of the game, add one to the index and run again
                    .then(function () {
                        index += 1;
                        self.loadAll(lanterns, index)
                            .then(deferred.resolve);
                    }, console.log);
            }
            
            return deferred.promise;
        };
        
        this.load = function (lanternData) {
            var deferred = Q.defer(),
                newLantern = new self.Lantern(lanternData);

            self.lanterns[newLantern._id] = newLantern;
            Forage.notify('Added lantern ' + newLantern.name + ' to game as ID: ' + newLantern._id);
            if (parentGame.lanterns.indexOf(newLantern._id) == -1) {
                parentGame.lanterns.push(newLantern._id);
                parentGame.save()
                    .then(function () {
                        deferred.resolve(newLantern);
                    });
            } else {
                deferred.resolve(newLantern);
            }
            
            return deferred.promise;
        };
        
        this.findById = function  (request_ids) {
            var deferred = Q.defer(),
                result = [], i;
            
            // Remove any white spaces and split the request string up into an array
            request_ids = request_ids.toString().replace(' ', '').split(',');
            
            // Loop over the existing lanterns to see if it matches anything in the array of request IDs
            for (i in self.lanterns) {
                if (request_ids.indexOf(self.lanterns[i]._id) >= 0) {
                    // Upon finding a match, add it to the result array
                    result.push(self.lanterns[i]);
                }
            }
            
            deferred.resolve(result);
            return deferred.promise;
        };
        
        this.findByResource = function (resource_ids) {
            var deferred = Q.defer(),
                i, r, result = [];
            
            if (typeof resource_ids === 'string') {
                resource_ids = resource_ids.split(',');
            }
            
            for (i = 0; i < parentGame.lanterns; i += 1) {
                for (r = 0; r < parentGame.lanterns[i].resources[r].length; r += 1) {
                    if (resource_id.indexOf(parentGame.lanterns[i].resources[r])) {
                        result.push(parentGame.lanterns[i]);
                        break;
                    }
                }
            }
            
            deferred.resolve(result);
            
            return deferred.promise;
        };
        
        this.findByRange = function (request, res) {
            var deferred = Q.defer();
            
            
            return deferred.promise;
        };
        
        this.capture = function (request, res) {
            var deferred = Q.defer();
            
            
            return deferred.promise;
        };
        
    };
    
    lanterns = new lanterns();
    
    module.parent.parent.parent.exports.MongoServer.addSchema('lantern', {
        game_id         : String,        // The game the lantern is associated to
        uid             : String,        // Device unique identifier
        name            : String,        // Name given to device (for within app)
        description     : String,        // Description of the lantern
        notation        : String,        // Any tip that is associated to it such as location
        status          : Number,        // Current status of the lantern (occupied, available, disabled, etcâ€¦)
        occupant        : String,        // unique player MongoDB _id string or empty
        resources       : [{
            resource_id : String,
            current     : Number,
            max         : Number
        }],
        geolocation     : {
            longitude       : Number,        // Location identifier
            latitude        : Number         // Location identifier
        }
    });
    
}());

module.exports = lanterns;